<?php
############################################################################
#       draw.class
#
#       Tim Traver
#       6/3/13
#       This is the draw Class for helping to manage the draw calculation process
#
############################################################################

class Draw {
	# Global class to handle event data and manipulation
	var $event_draw_id;
	var $event_id;
	var $draw=array();
	var $pilots=array();
	var $teams=array();
	var $rounds=array();
	var $grow_only;
	var $stats=array();
	
	function Draw($event_draw_id){
		# Initialization of the class
		$this->event_draw_id=$event_draw_id;
		$stmt=db_prep("
			SELECT *
			FROM event_draw
			WHERE event_draw_id=:event_draw_id
		");
		$result=db_exec($stmt,array("event_draw_id"=>$this->event_draw_id));
		$this->draw=$result[0];
		$this->event_id=$this->draw['event_id'];
		$this->get_pilots();
		$this->grow_only=0;
	}
	function get_pilots(){
		# Now lets get the pilots assigned to this event
		$stmt=db_prep("
			SELECT *
			FROM event_pilot ep
			LEFT JOIN pilot p ON ep.pilot_id=p.pilot_id
			WHERE ep.event_id=:event_id
				AND ep.event_pilot_status=1
		");
		$results=db_exec($stmt,array("event_id"=>$this->event_id));
		foreach($results as $pilot){
			$event_pilot_id=$pilot['event_pilot_id'];
			$team=$pilot['event_pilot_team'];
			$this->pilots[$event_pilot_id]=$pilot;
			$this->teams[$team][$event_pilot_id]=$pilot;
		}
		return;
	}
	function get_teams(){
		# Function to get the unique teams in an event
		$names=array();
		$stmt=db_prep("
			SELECT DISTINCT(ep.event_pilot_team)
			FROM event_pilot ep
			LEFT JOIN event e ON ep.event_id=e.event_id
			LEFT JOIN pilot p ON ep.pilot_id=p.pilot_id
			WHERE ep.event_pilot_team !=''
				AND e.event_id=:event_id
				AND ep.event_pilot_status=1
		");
		$names=db_exec($stmt,array("event_id"=>$this->event_id));
		$this->teams=$names;
		return;
	}
	function create_random_rounds($recalc=0){
		# Function to create the round array for an order type of round
		# This means we essentially create the random array for speed rounds
		# The $recalc variable is to tell it to recalculate the rounds even if existing, if not, it leaves them alone
		
		$round_from=$this->draw['event_draw_round_from'];
		$round_to=$this->draw['event_draw_round_to'];
		
		# Lets turn off any rounds that are outside the range
		$stmt=db_prep("
			UPDATE event_draw_round
			SET event_pilot_id=0,
				event_draw_round_group='',
				event_draw_round_status=0
			WHERE event_draw_id=:event_draw_id
				AND (event_draw_round_number<:round_from OR event_draw_round_number>:round_to)
				
		");
		$result=db_exec($stmt,array(
			"event_draw_id"=>$this->event_draw_id,
			"round_from"=>$round_from,
			"round_to"=>$round_to
		));
		
		$last_team='';
		for($round=$round_from;$round<=$round_to;$round++){
			$round_ok=1;
			$order=array();
			$pilots=$this->pilots;
			shuffle($pilots);
			$loop=count($pilots);
			$total_pilots=count($pilots);
			# Set a y value to prevent looping
			$y=0;
			for($x=1;$x<=$loop;$x++){
				if(count($pilots)>1){
					$rand=mt_rand(0,$total_pilots);
					$test=array_slice($pilots,$rand-1,1);
					if($test[0]['event_pilot_team']!=$last_team || $test[0]['event_pilot_team']=='' || $this->draw['event_draw_team_separation']==0 || $y>20){
						# This chosen one is indeed on a different team, so lets pop it off the array
						$splice=array_splice($pilots,$rand-1,1);
						$order[]=$splice[0];
						$total_pilots--;
						$last_team=$splice[0]['event_pilot_team'];
						if($y>20){
							$round_ok=0;
						}
						$y=0;
					}else{
						# Try again by resetting the x var
						$x--;
						$y++;
					}
				}else{
					$order[]=$pilots[0];
					$total_pilots--;
					$last_team=$pilots[0]['event_pilot_team'];
				}
			}
			if($round_ok==0){
				# This means that the separation didn't work
				$round--;
			}
			
			# Now lets step through the array and save the round info
			$x=1;
			foreach($order as $key=>$o){
				# Lets see if a record already exists
				$event_draw_round_id=0;
				$stmt=db_prep("
					SELECT event_draw_round_id
					FROM event_draw_round
					WHERE event_draw_id=:event_draw_id
						AND event_draw_round_number=:round
						AND event_draw_round_order=:event_draw_round_order
						AND event_draw_round_status=1
				");
				$result=db_exec($stmt,array("event_draw_id"=>$this->event_draw_id,"round"=>$round,"event_draw_round_order"=>$x));
				if(isset($result[0])){
					$event_draw_round_id=$result[0]['event_draw_round_id'];
				}
				
				if($event_draw_round_id==0){
					# Make a new record
					$stmt=db_prep("
						INSERT INTO event_draw_round
						SET event_draw_id=:event_draw_id,
							event_draw_round_number=:event_draw_round_number,
							event_pilot_id=:event_pilot_id,
							event_draw_round_group='',
							event_draw_round_order=:x,
							event_draw_round_status=1
					");
					$result=db_exec($stmt,array(
						"event_draw_id"=>$this->event_draw_id,
						"event_draw_round_number"=>$round,
						"event_pilot_id"=>$o['event_pilot_id'],
						"x"=>$x
					));
				}else{
					if($recalc==1){
						# Update an existing record if its being recalced
						$stmt=db_prep("
							UPDATE event_draw_round
							SET event_pilot_id=:event_pilot_id,
								event_draw_round_group='',
								event_draw_round_order=:x,
								event_draw_round_status=1
							WHERE event_draw_round_id=:event_draw_round_id
						");
						$result=db_exec($stmt,array("event_draw_round_id"=>$event_draw_round_id,"event_pilot_id"=>$o['event_pilot_id'],"x"=>$x));
					}
				}
				$x++;
			}
		}
		return;
	}
	function create_random_step_rounds($recalc=0){
		# Function to create the round array for an random draw with a step
		# We create the first round as random, and then step the pilots forward X amount every round
		# The $recalc variable is to tell it to recalculate the rounds even if existing, if not, it leaves them alone
		
		$round_from=$this->draw['event_draw_round_from'];
		$round_to=$this->draw['event_draw_round_to'];
		
		# Lets turn off any rounds that are outside the range
		$stmt=db_prep("
			UPDATE event_draw_round
			SET event_pilot_id=0,
				event_draw_round_group='',
				event_draw_round_status=0
			WHERE event_draw_id=:event_draw_id
				AND (event_draw_round_number<:round_from OR event_draw_round_number>:round_to)
				
		");
		$result=db_exec($stmt,array(
			"event_draw_id"=>$this->event_draw_id,
			"round_from"=>$round_from,
			"round_to"=>$round_to
		));
		
		$existing_first=array();
		if($recalc==0){
			# Lets see if we can get the first round of the existing range to use as the start order
			$stmt=db_prep("
				SELECT *
				FROM event_draw_round edr
				LEFT JOIN event_pilot ep ON edr.event_pilot_id=ep.event_pilot_id
				LEFT JOIN pilot p ON ep.pilot_id=p.pilot_id
				WHERE edr.event_draw_id=:event_draw_id
					AND edr.event_draw_round_number=:round_from
					AND edr.event_draw_round_status=1
			");
			$existing_first=db_exec($stmt,array(
				"event_draw_id"=>$this->event_draw_id,
				"round_from"=>$round_from
			));
		}
				
		$last_team='';
		$first_round=1;
		$order=array();
		$step=$this->draw['event_draw_step_size'];
		for($round=$round_from;$round<=$round_to;$round++){
			$round_ok=1;
			
			if($first_round && count($existing_first)>0 && $recalc==0){
				$order=$existing_first;
				$first_round=0;
				continue;
			}
			
			if($first_round){
				$pilots=$this->pilots;
				shuffle($pilots);
				$loop=count($pilots);
				$total_pilots=count($pilots);
				# Set a y value to prevent looping
				$y=0;
				for($x=1;$x<=$loop;$x++){
					if(count($pilots)>1){
						$rand=mt_rand(0,$total_pilots);
						$test=array_slice($pilots,$rand-1,1);
						if($test[0]['event_pilot_team']!=$last_team || $test[0]['event_pilot_team']=='' || $this->draw['event_draw_team_separation']==0 || $y>20){
							# This chosen one is indeed on a different team, so lets pop it off the array
							$splice=array_splice($pilots,$rand-1,1);
							$order[]=$splice[0];
							$total_pilots--;
							$last_team=$splice[0]['event_pilot_team'];
							if($y>20){
								$round_ok=0;
							}
							$y=0;
						}else{
							# Try again by resetting the x var
							$x--;
							$y++;
						}
					}else{
						$order[]=$pilots[0];
						$total_pilots--;
						$last_team=$pilots[0]['event_pilot_team'];
					}
				}
				if($round_ok==0){
					# This means that the separation didn't work
					$round--;
					continue;
				}
			}else{
				# After the first round, now we will just move the array forward X amount
				# We just need to grab the offset of the array and re-order it
				$temp=array();
				for($x=1;$x<=$step;$x++){
					$temp=array_shift($order);
					$order[]=$temp;
				}
			}
			$first_round=0;
				
			# Now lets step through the array and save the round info
			$x=1;
			foreach($order as $key=>$o){
				# Lets see if a record already exists
				$event_draw_round_id=0;
				$stmt=db_prep("
					SELECT event_draw_round_id
					FROM event_draw_round
					WHERE event_draw_id=:event_draw_id
						AND event_draw_round_number=:round
						AND event_draw_round_order=:event_draw_round_order
						AND event_draw_round_status=1
				");
				$result=db_exec($stmt,array("event_draw_id"=>$this->event_draw_id,"round"=>$round,"event_draw_round_order"=>$x));
				if(isset($result[0])){
					$event_draw_round_id=$result[0]['event_draw_round_id'];
				}
				
				if($event_draw_round_id==0){
					# Make a new record
					$stmt=db_prep("
						INSERT INTO event_draw_round
						SET event_draw_id=:event_draw_id,
							event_draw_round_number=:event_draw_round_number,
							event_pilot_id=:event_pilot_id,
							event_draw_round_group='',
							event_draw_round_order=:x,
							event_draw_round_status=1
					");
					$result=db_exec($stmt,array(
						"event_draw_id"=>$this->event_draw_id,
						"event_draw_round_number"=>$round,
						"event_pilot_id"=>$o['event_pilot_id'],
						"x"=>$x
					));
				}else{
					# Update an existing record
					if($recalc==1){
						$stmt=db_prep("
							UPDATE event_draw_round
							SET event_pilot_id=:event_pilot_id,
								event_draw_round_group='',
								event_draw_round_order=:x,
								event_draw_round_status=1
							WHERE event_draw_round_id=:event_draw_round_id
						");
						$result=db_exec($stmt,array("event_draw_round_id"=>$event_draw_round_id,"event_pilot_id"=>$o['event_pilot_id'],"x"=>$x));
					}
				}
				$x++;
			}
		}
		return;
	}
	function create_group_rounds($recalc=0){
		# Function to create the round array for an order type of group round
		# We will create a random first round and then iterate through the rounds, adding stats along the way
		# The $recalc variable is to tell it to recalculate the rounds even if existing, if not, it leaves them alone
		
		$round_from=$this->draw['event_draw_round_from'];
		$round_to=$this->draw['event_draw_round_to'];
		
		# Lets turn off any rounds that are outside the range
		$stmt=db_prep("
			UPDATE event_draw_round
			SET event_pilot_id=0,
				event_draw_round_group='',
				event_draw_round_status=0
			WHERE event_draw_id=:event_draw_id
				AND (event_draw_round_number<:round_from OR event_draw_round_number>:round_to)
				
		");
		$result=db_exec($stmt,array(
			"event_draw_id"=>$this->event_draw_id,
			"round_from"=>$round_from,
			"round_to"=>$round_to
		));
		
		
		# If they want to take the statistics from the previously applied rounds, then do that here
		# (insert code for retrieval of stats from previous rounds)
		$groups=$this->get_group_array();

		$first_round=1;
		for($round=$round_from;$round<=$round_to;$round++){
			$round_ok=1;
			
			$this_round=array();
			if($first_round==1){
				# Lets make the first round a random draw taking into account the protection
				do{
					$pilots=$this->pilots;
					$total_pilots=count($pilots);
					$round_ok=1;
					$this_round_attempt=array();
					# Lets step through the group structure
					foreach($groups as $group_num=>$number_group_pilots){
						$this_group_array=array();
						$this_group_teams=array();
						for($x=1;$x<=$number_group_pilots;$x++){
							$clear=0;
							$y=0; # set value to make sure it doesn't continually loop
							do{
								$rand=mt_rand(0,$total_pilots);
								if($this->draw['event_draw_team_protection']==1){
									# This draw has team protection, so lets see if this choice is already on a team in this group
									$test=array_slice($pilots,$rand-1,1);
									if(!in_array($test[0]['event_pilot_team'],$this_group_teams)){
										$clear=1;
									}else{
										$y++;
										if($y>20){
											# This means that we've done this loop more than 20 times with no success so we might be in a loop
											# Try again by resetting the x var
											break;
										}
									}
								}else{
									$clear=1;
								}
							} while($clear==0);
							if($y>20){
								# We didn't get the group ok, so lets start the group over
								$round_ok=0;
								print "breaking out of loop, cause we couldn't get a pilot chosen that had protection<br>\n";
								break(2);
							}
							# This is where we got a good group, so lets set it and continue
							$temp_pilot=array_splice($pilots,$rand-1,1);
							$this_group_array[]=$temp_pilot[0];
							$this_group_teams[]=$temp_pilot[0]['event_pilot_team'];
							$total_pilots--;
						}
						$this_round_attempt[$group_num]=$this_group_array;					
					}
					if($round_ok==1){
						$this_round[$round]=$this_round_attempt;
					}
				} while($round_ok==0);
				
				$first_round=0;
				
				foreach($this_round as $temp_round=>$r){
					print "Round #$temp_round<br>\n";
					foreach($r as $temp_group=>$g){
						print "\tGroup #$temp_group<br>\n";
						foreach($g as $key=>$p){
							#print_r($p);
							print "\t\t{$p['event_pilot_team']} - {$p['pilot_first_name']} {$p['pilot_last_name']}<br>\n";
						}
					}
				}
				
				
			}else{
				# This is a subsequent round, so we will be taking in the stats in addition to random to create it
			
			
			
			}
			
		}
		return;
	}
	
	function add_round_to_stats($round){
	
	
	}
	function get_group_array(){
		# Function to determine the number of groups and members in each group from the settings
		$num_pilots=count($this->pilots);
		$num_groups=$this->draw['event_draw_number_groups'];
		$per_group=floor($num_pilots/$num_groups);
		$left_over=$num_pilots % $num_groups;
		
		$groups=array();
		if($left_over==0){
			for($x=1;$x<=$num_groups;$x++){
				$groups[$x]=$per_group;
			}
		}else{
			# Set the number of groups at the higher value first
			for($x=1;$x<=($left_over);$x++){
				$groups[$x]=$per_group+1;
			}
			for($x=$x;$x<=$num_groups;$x++){
				$groups[$x]=$per_group;
			}
		}
		return $groups;
	}
	
	
}
?>